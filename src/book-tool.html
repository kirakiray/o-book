<template component>
  <style>
    :host {
      display: block;
      padding: 16px;
    }

    .nav-item {
      margin: 8px;
      padding: 8px;
      border: #888888 solid 1px;
    }
  </style>
  <x-if :value="loading"> 加载中。。。 </x-if>
  <x-else>
    <div>o-book 生成器</div>
    <button on:click="download">下载</button>
    <h3>预览</h3>

    <select sync:value="currentLang" on:change="changeLang">
      <template is="replace-temp">
        <x-fill :value="langOptions">
          <option attr:value="$data.value">{{$data.name}}</option>
        </x-fill>
      </template>
    </select>
    <div>
      <x-fill :value="navs">
        <div class="nav-item">
          <h4>{{$data.name}}</h4>
          <ul>
            <x-fill :value="$data.articles" name="li"></x-fill>
          </ul>
        </div>
      </x-fill>
    </div>
  </x-else>
  <template name="li">
    <li>
      <a attr:href="$data.fixedHref || null" target="_blank">{{$data.name}}</a>
      <ul>
        <x-fill :value="$data.childs" name="li"></x-fill>
      </ul>
    </li>
  </template>
  <script>
    import { getSummary } from "../statics/util.mjs";
    import storage from "./storage/index.mjs";
    import "https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";

    const langOpts = {
      en: "English",
      cn: "简体中文",
      "t-cn": "繁体中文",
      es: "española",
    };

    export default {
      attrs: {
        sw: "",
      },
      data: {
        loading: true,
        navs: [],
        currentLang: "",
        langOptions: [],
      },
      proto: {
        changeLang(e) {
          this.init(this.srcs.find((item) => item.lang === e.target.value).src);
        },
        async init(src) {
          const jsonUrl = new URL("@/" + src, location.href).href;
          const data = await new Promise(async (resolve) => {
            while (true) {
              try {
                const data = await fetch(jsonUrl).then((e) => e.json());
                resolve(data);
                break;
              } catch (err) {
                debugger;
                await new Promise((res) => setTimeout(res, 500));
                location.reload();
              }
            }
          });

          const { navs } = data;

          navs.forEach((e) => {
            const summaryUrl = new URL(e.summary, jsonUrl).href;

            fixArticles(e.articles, summaryUrl);
          });

          this.navs = navs;
        },
        async loadArticles() {
          await this.init(this.srcs[0].src);

          if (location.hash === "#upload-zip") {
            this._postZip();
          }
        },
        async _postZip() {
          const zip = await this.getZip();

          const data = await zip.generateAsync({ type: "blob" });

          console.log("pd: ", data);

          let uploadFileRequest = new Request(`/postzip`, {
            method: "post",
            body: data,
          });

          const result = await fetch(uploadFileRequest).then((e) => e.json());

          console.log("result :", result);
        },
        async download() {
          const zip = await this.getZip();

          // 下载
          zip.generateAsync({ type: "blob" }).then((content) => {
            saveAs(content, "example.zip");
          });
        },
        async getZip() {
          const zip = new JSZip();

          const fileUrls = [];

          const eachChilds = (item) => {
            const { fixedHref, childs } = item;

            if (fixedHref) {
              fileUrls.push(fixedHref);
              return;
            }

            if (childs) {
              childs.forEach((e) => eachChilds(e));
            }
          };

          await Promise.all(
            this.srcs.map(async ({ src }) => {
              const jsonUrl = new URL("@/" + src, location.href).href;
              const libUrl = jsonUrl.replace(/(.+)\/.+/, "$1/libs.json");

              const jdata = await fetch(jsonUrl).then((e) => e.json());

              // 先获取所有需要存储的文件数组后，再进行请求下载并打包
              fileUrls.push(jsonUrl, libUrl);

              jdata.navs.forEach((e) => {
                fixArticles(e.articles, new URL(e.summary, jsonUrl).href);
              });

              jdata.navs.forEach((e) => {
                const { articles } = e;

                articles.forEach((item) => eachChilds(item));
              });
            })
          );

          await Promise.all(
            fileUrls.map(async (e) => {
              const data = await fetch(e).then((e) => e.text());

              const path = e.split("/@/")[1];

              zip.file(path, data);
            })
          );

          return zip;
        },
        get srcs() {
          const srcs = [];
          this.forEach((e) => {
            if (e.tag === "source") {
              const lang = e.attr("lang") || "en";
              const src = e.attr("src");
              if (src) {
                srcs.push({
                  lang,
                  src,
                });
              }
            }
          });

          return srcs;
        },
      },
      ready() {
        const { srcs } = this;

        this.langOptions = srcs.map((e) => {
          return {
            name: langOpts[e.lang],
            value: e.lang,
          };
        });

        this.currentLang = srcs[0].lang;
      },
      watch: {
        async sw(sw) {
          if (this.__sw) {
            throw "The sw attribute is already in effect and cannot be changed.";
          }
          if (!sw) {
            return;
          }

          const { srcs } = this;

          if (!srcs.length) {
            return;
          }

          this.__sw = sw;

          await storage.setItem("config-url", srcs);

          const injectHead = this.$("template[inject-head]");
          if (injectHead) {
            await storage.setItem("inject-head", injectHead.html);
          } else {
            await storage.setItem("inject-head", "");
          }

          await new Promise((res) => setTimeout(res), 100);

          await navigator.serviceWorker
            .register(new URL(sw, location.href).href, {
              scope: "./",
            })
            .then((reg) => {
              setTimeout(() => {
                reg.update();
              }, 60 * 60 * 1000);
            })
            .catch((err) => {
              console.error(err);
            });

          await new Promise((res) => setTimeout(res), 500);

          await this.loadArticles();

          this.loading = false;
        },
      },
    };

    function fixArticles(arr, relateUrl) {
      arr.forEach((e) => {
        if (e.childs) {
          fixArticles(e.childs, relateUrl);
          return;
        }

        e.fixedHref = new URL(e.href, relateUrl).href.replace(/\.md/, ".html");
      });
    }

    function saveAs(file, fileName) {
      const blobUrl = URL.createObjectURL(file);

      const downloadLink = document.createElement("a");
      downloadLink.href = blobUrl;
      downloadLink.download = fileName || file.name;
      downloadLink.style.display = "none";

      document.body.appendChild(downloadLink);
      downloadLink.click();

      URL.revokeObjectURL(blobUrl);
      document.body.removeChild(downloadLink);
    }
  </script>
</template>
